Date: 2014 June 22 10:00
Title: Scripting with Golang
Categories: golang, go, bash, scripting
Tags: golang, go, bash, scripting
Flags: draft

# Scripting with [Golang][Go]

One thing I love about [Go] over interperted languages is that a compiled binary doesn't care about what version of the [Go] compiler you're running. I've recently been tackling [Hadoop] and [Hive] and as part of the project I'm working on, I want to run regular queries and insert summary data into [ElasticSearch] for graphing and reporting. The [Hive] jump box I'm using has very old versions ofboth [Ruby] (1.8.6) and [Python] (2.4). As such, I chose to my scripting in [Go].

Today, I'm going to talk about using [Go] to access other commands &ndash; navite commands, scripts, etc. &ndash; in a Linux environment, specifically CentOS 5. That said, the infomration here should carry over, easily to other unix based distrobutions, and may (with a bit of tweaking) also work under Windows.

### Basic Execution

The most basic way to execute (through native [Go]) of an external command would be through the [`os/exec`] package and it's `Command` method.

In this first example, we'll use `Output` to run the data command and print the results of `STDOUT`.

	out, err := exec.Command("date").Output()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("The date is %s\n", out)

> [See this example in Go Playground](http://play.golang.org/p/1-kCAKb5hN)

But let's say you need both `STDOUT` and `STDERR`, [Go]'s [`os/exec`] package provides `CombinedOutput` for that used in exactly the same way.

	out, err := exec.Command("date").CombinedOutput()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("The date is %s\n", out)

> [See this example in Go Playground](http://play.golang.org/p/jrVF-WDwXS)

The [`os/exec`] packages provides additional resouces for more complex handling of external execution, so I highly recommend reading up on it.


## Advanced Execution through [`Sh`]

One important element of any language used for scripting is how quickly and simple a script can be "hacked together" (so to speak). Given [Go]'s strict nature, that can be a bit difficult at times &ndash; especially when first learning [Go]. One of the first packages I created when first learning [Go] was a simple command executer I call [`Sh`]. 

The goal of [`Sh`] is to wrap handling of shell execution in very easy to use manner and return `string`(s) with the output streams and simple pass/fail through `error`. As such, there are two key methods, `Sh` (which returns combined `STDOUT` and `STDERR`) and `Sh2` (which returns `STDOUT` and `STDERR` seperately.

    package main
    import (
        "log"
        "fmt"
        "github.com/jmervine/sh"
    )
    
    func main() {
        
        // using Sh to ensure that command exists
        if _, err := sh.Sh("which hive", false); err != nil {
            log.Fatalln("hive command not found")
        }
        
        // using Sh2 to execute command
        query := `select count(*) from nginx_access_logs where yyyy=2014 and mm=06 and dd=03`
        cmd   := fmt.Sprintf("hive -S -e '%s'", query)
                    
        if stdout, stderr, err := sh.Sh2(cmd, false); if err != nil {
            log.Fatalln(stderr)
        } else {
            log.Println(stdout)
        }
    }
    
> Note: Currently both `Sh` and `Sh2` take a `bool` to indicate wheather or not to stream command output to `os.Stdout` and/or `os.Stderr`. In the future (probably soon) I'll be updating this to instead take a stream to stream to, something like `Sh2(cmd, os.Stdout, os.Stderr)`.


[Go]: http://golang.org/
[`os/exec`]: http://golang.org/pkg/os/exec/
[`Sh`]: http://godoc.org/github.com/jmervine/sh
